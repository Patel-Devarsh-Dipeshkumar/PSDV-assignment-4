[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Exposition Assignment",
    "section": "",
    "text": "Sympy Combinatorics\n\n\n\n\n\n\nML\n\n\n\n\n\n\n\n\n\nFeb 22, 2025\n\n\nPatel Devarsh Dipeshkumar\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Expsoition article.html",
    "href": "posts/Expsoition article.html",
    "title": "Sympy Combinatorics",
    "section": "",
    "text": "Sympy Combinatorics\n\n\nSymPy is an open-source Python library for symbolic mathematics. It allows users to perform algebraic computations, solve equations, manipulate expressions, and work with calculus, linear algebra, and more.\n\n\n\nIntroduction to SymPy Combinatorics\n\n\n\nSymPy’s Combinatorics module provides tools for working with partitions, permutations, and other discrete structures in mathematics. It is useful in combinatorial problems, group theory, and counting principles.\n\n\n\nInstallation Steps\n\n\n\nSympy could be installed with the help of pip which is Python Package Manager\n\n\n\n1. Install Using pip  Open a terminal or command prompt and run: pip install sympy\n\n\npip install sympy\n\nRequirement already satisfied: sympy in c:\\users\\hp\\appdata\\local\\programs\\python\\python312\\lib\\site-packages (1.13.3)\nRequirement already satisfied: mpmath&lt;1.4,&gt;=1.1.0 in c:\\users\\hp\\appdata\\local\\programs\\python\\python312\\lib\\site-packages (from sympy) (1.3.0)\nNote: you may need to restart the kernel to use updated packages.\n\n\n\n[notice] A new release of pip is available: 24.0 -&gt; 25.0.1\n[notice] To update, run: python.exe -m pip install --upgrade pip\n\n\n\n2. Verify Installation  After installation, open Python and type\n\n\nimport sympy\nprint(sympy.__version__)  # It should print the installed SymPy version\n\n1.13.3\n\n\n\n\n\nTopic 1:- Partition\n\n\n\nIn simple words, a partition is a set of disjoint sets whose union equals a given set.\n\n\nProblem 1) Imagine a teacher has 6 students: {1, 2, 3, 4, 5, 6} and wants to divide them into study groups based on their subject preferences. Each student belongs to exactly one group. Group 0 (Math Lovers) → {1, 2, 3}; Group 1 (Science Enthusiasts) → {4, 5}; Group 2 (History Buffs) → {6}\n\n\nWe can solve this problem easily by using “Partitions”. So for that first of all we need to learn some basic properties.\n\n\n\n\n\nProperties of Partition\n\n\n\n 1. RGS\n\n\n\nIt returns the “restricted growth string” of the partition.  Explanation - The RGS is given as a list of numbers, L, where each number L[i] tells you which indices the i-th element belongs to.\n\n\n\nfrom sympy.combinatorics import Partition              #Importing the Partition class from the sympy.combinatorics module.\nExample_RGS = Partition([1,2,3],[8,9],[4,5],[6],[7])   #Defining a partition of a set containing the elements {1,2,3,4,5,6,7,8,9}.\nprint(Example_RGS.members)                             #Here \".members\" returns a tuple of elements in sorted order.\nprint(Example_RGS.RGS)                                 #.RGS returns a tuple of indices, where each index tells us which block the corresponding element belongs to\n\n(1, 2, 3, 4, 5, 6, 7, 8, 9)\n(0, 0, 0, 1, 1, 2, 3, 4, 4)\n\n\nNow we can easily answer the ‘Q1)’ by using this property.\n\nstudy_groups = Partition([1, 2, 3], [4, 5], [6])\nprint(\"Partition:\", study_groups.partition)\nprint(\"RGS Representation:\", study_groups.RGS)\n\nPartition: [[1, 2, 3], [4, 5], [6]]\nRGS Representation: (0, 0, 0, 1, 1, 2)\n\n\nFrom the Output we can conclude that Students {1,2,3} are in group 0. Students {4,5} are in group 1. Student {6} is in group 2.\n\n\n 2. Partition\n\n\n\nIt returns partition as a sorted list of lists.\n\nExplanation - A Partition in SymPy divides a set into disjoint, non-empty subsets (blocks) whose union equals the original set. The .partition attribute returns these blocks as a list of lists, representing the partition structure.\n\nfrom sympy.combinatorics import Partition\nExample_Partition = Partition([4], [2, 5]).partition\nprint(Example_Partition)\n\n[[2, 5], [4]]\n\n\n\n\n 3. Rank\n\n\n\nIt gets the rank of a partition.\n\nExplanation - The .rank attribute of a Partition in SymPy gives a unique integer representing the partition’s position in the lexicographic ordering of all partitions of the same set.\n\nfrom sympy.combinatorics import Partition\nExample_Rank = Partition([1, 2], [3], [4, 5])\nprint(Example_Rank.rank)\n\n13\n\n\n\n\n 4. Conjugate\n\n\n\nIt computes the conjugate partition of itself.\n\nExplanation - In SymPy, the .conjugate of an IntegerPartition interchange the rows and columns in its Ferrers diagram representation, transforming the partition into another valid partition.\n\nfrom sympy.combinatorics.partitions import IntegerPartition\nExample_Conjugate = IntegerPartition([6, 3, 3, 2, 1])\nprint(Example_Conjugate.conjugate)\n\n[5, 4, 3, 1, 1, 1]\n\n\n\n\nTopic 2:- Subsets\n\n\n\nIn simple words, it represents a basic subset object.\n\nExplanation - There are two main ways to create subsets: binary enumeration and lexicographic enumeration. In SymPy, the Subset class needs two inputs: the first is the subset we start with, and the second is the larger set it comes from.\nSome basic Examples of Subset\n\nfrom sympy.combinatorics import Subset\na = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\nprint(a.next_binary().subset)\n\n['b']\n\n\n\nLet’s take a practical example.\n\n\nImagine a smart home system with 4 devices that can be turned ON or OFF:\n&lt;br&gt;&lt;br&gt;\n1. Lights ('L')&lt;br&gt;\n2. Fan ('F')&lt;br&gt;\n3. TV ('T')&lt;br&gt;\n4. AC ('A')&lt;br&gt;\n&lt;br&gt;\nA subset of these devices represents the currently active (ON) devices.\n\n\nNow the problem is that we need to track which devices are ON at any moment and the system wants to automatically switch to the next possible combination of ON devices.\n\n\nfrom sympy.combinatorics import Subset\nall_devices = ['L', 'F', 'T', 'A']                   #First of all defining the all devices in a list in short form for ease.\ncurrent_on_devices = Subset(['T', 'A'], all_devices)   # Define the initial subset (devices that are ON)\nnext_on_devices = current_on_devices.next_binary().subset   # Get the next possible subset in binary order (next device combination)\nprint(\"All Devices:\", all_devices)\nprint(\"Currently ON Devices:\", current_on_devices.subset)\nprint(\"Next ON Device Combination:\", next_on_devices)\n\nAll Devices: ['L', 'F', 'T', 'A']\nCurrently ON Devices: ['T', 'A']\nNext ON Device Combination: ['F']\n\n\n\nSo this algorithm helps us to find the Devices which are currently ON and also gives the knowledge about the next device which is ON.\n\n\n\nProperties of Subsets\n\n\n\n 1. Cardinality\n\n\n\nIt returns the number of all possible subsets.\n\nExplanation - The .cardinality property in SymPy returns the total number of possible subsets of a given set. Since a set with n elements has (2^n) subsets, this property calculates and returns that value.\n\nfrom sympy.combinatorics import Subset\nExample_Cardinality = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\nprint(Example_Cardinality.cardinality)\n\n16\n\n\n\n\n 2. Subset\n\n\n\nIt gets the subset represented by the current instance.\n\nThe .subset property in SymPy returns the current subset being considered. It simply gives the list of elements that form the subset within the given superset.\n\nfrom sympy.combinatorics import Subset\nExample_Subset = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\nprint(Example_Subset.subset)\n\n['c', 'd']\n\n\n\n\n 3. Superset\n\n\n\nIt gets the superset of the subset.\n\nExplanation - The .superset property in SymPy returns the original (universal) set from which subsets are created. It shows the complete set that contains all possible elements for forming subsets.\n\nfrom sympy.combinatorics import Subset\nExample_Superset = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\nprint(Example_Superset.superset)\n\n['a', 'b', 'c', 'd']\n\n\n\n\n 4. Size\n\n\n\nIt gets the size of the subset.\n\nExplanation - The .size property in SymPy returns the number of elements in the current subset. It simply counts how many elements are present in the subset.\n\nfrom sympy.combinatorics import Subset\nExample_Size = Subset(['a', 'c', 'd'], ['a', 'b', 'c', 'd'])\nprint(Example_Size.size)\n\n3\n\n\n\n\n 5. Superset Size\n\n\n\nIt returns the size of the superset.\n\nExplanation - The .superset_size property in SymPy returns the number of elements in the superset. It simply gives the total count of elements in the original (universal) set from which subsets are formed.\n\nfrom sympy.combinatorics import Subset\nExample_Superset_size = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\nprint(Example_Superset_size.superset_size)\n\n4\n\n\n\n\nTopic 3:- Gray Code\n\n\n\nA Gray code is a way of listing all possible subsets of a set so that each new subset differs from the previous one by adding or removing just one element. This helps in efficient subset generation and has applications in computing and statistics.\n\n\n\n\nProperties of Gray Code\n\n\n\n 1. Current\n\n\n\nIt returns the currently referenced Gray code as a bit string.\n\nExplanation - The .current attribute shows the Current Gray code value in the sequence and if a starting value is given, it starts from that value instead of the default (000).\n\nfrom sympy.combinatorics import GrayCode\nExample_Current_1 = GrayCode(3, start='100').current\nprint(Example_Current_1)\nfrom sympy.combinatorics import GrayCode\nExample_Current_2 = GrayCode(3).current\nprint(Example_Current_2)\n\n100\n000\n\n\n\n\n 2. Property n\n\n\n\nIt returns the dimension of the Gray code.\n\nExplanation - The .n attribute gives the number of bits used in the Gray code. In this case, it returns 5, meaning the Gray code sequence is for 5-bit numbers.\n\nfrom sympy.combinatorics import GrayCode\nExample_Dimension = GrayCode(5)\nprint(Example_Dimension.n)\n\n5\n\n\n\n\n 3. Rank\n\n\n\nIt ranks the Gray code.\n\nExplanation - A ranking algorithm finds the position of a combinatorial object in a list of all possible objects, based on a specific order.\n\nfrom sympy.combinatorics import GrayCode\nExample = GrayCode(3)\nprint(list(Example.generate_gray()))\nExample_Rank_1 = GrayCode(3, start='100').rank\nprint(\"The Rank of '100' is:\", Example_Rank_1)\nExample_Rank_2 = GrayCode(3, start='111').rank\nprint(\"The Rank of '111' is:\", Example_Rank_2)\n\n['000', '001', '011', '010', '110', '111', '101', '100']\nThe Rank of '100' is: 7\nThe Rank of '111' is: 5\n\n\n\n\n 4. Selections\n\n\n\nIt returns the number of bit vectors in the Gray code.\n\nExplanation - The .selections property tells us how many values exist in the Gray code sequence. For example in n-bit Gray code, this number is always 2^n.\n\nfrom sympy.combinatorics import GrayCode\nExample_Selections_1 = GrayCode(3)\nprint(Example_Selections_1.selections)\nExample_Selections_2 = GrayCode(5)\nprint(Example_Selections_2.selections)\n\n8\n32\n\n\n\n\nTopic 4:- Permutations\n\n\n\nPermutation is an important subdivision of sympy.combinatorics, they are fundamental concepts in combinatorics, representing the various ways to arrange a set of elements where the order is significant. In SymPy, the Permutation class provides tools to create and manipulate these arrangements.\n\n\nTo define a permutation, you specify a list that indicates the new positions of elements. Let us understand this with an example, Permutation([2, 0, 1]) rearranges elements such that the element at index 0 moves to index 2, the element at index 1 moves to index 0, and the element at index 2 moves to index 1.\n\nHere’s the code:\n\nfrom sympy.combinatorics import Permutation\n\np = Permutation([2, 0, 1]) # We define the permutation here\n\nprint(\"Permutation is:\", p) \n\nPermutation is: (0 2 1)\n\n\n\nExplanation\n&lt;br&gt; &lt;br&gt;\nIn this cycle notation, (0 2 1) indicates that index 0 maps to index 2, index 2 maps to index 1, and index 1 maps back to index 0, forming a cycle.\n\n\nHow can we apply permuation to a List?\n\n\nTo apply this permutation to a list of elements [A, B, C]:\n\n\n\noriginal_elements = ['A', 'B', 'C']\n\np = Permutation([2, 0, 1])\n\npermuted_elements = [original_elements[i] for i in p.array_form] #here the function .array_form just gives us an array of the permutation p\n\nprint(\"Original List:\", original_elements)           \nprint(\"Permuted List:\", permuted_elements)  \n\nOriginal List: ['A', 'B', 'C']\nPermuted List: ['C', 'A', 'B']\n\n\n\nThis code rearranges the list [‘A’, ‘B’, ‘C’] to [‘B’, ‘C’, ‘A’] based on the permutation [2,0,1] as:\n\n\nThe element at pos 0 maps to the index 1 , the element at pos 1 maps to the index 2 and the element at the pos 2 maps athe index 0.\n\n\n\nHow can we apply permuation to a List?\n\n\n\nPermutations play a crucial role in cryptography, particularly in the design of encryption algorithms. By permuting bits or blocks of data, encryption schemes can obscure the original information, enhancing security.\n\n\n\n\nProperties of Permutations\n\n\n\n 1. Identity Permutation\n\n\n\nA permutation where all elements remain in their original positions.\n\n\nfrom sympy.combinatorics import Permutation\n\n# here we have an identity permutation of size 4\np = Permutation([0, 1, 2, 3])\nprint(\"Identity Permutation:\", p)\n\nIdentity Permutation: (3)\n\n\nIn this example,each element maps with itself suggesting no change in the position of the element.\n\n\n 2. Inverse of Permutation\n\n\n\nA permutation that, when composed with the original, yields the identity permutation.\n\n\nfrom sympy.combinatorics import Permutation\n\n#here we Define a permutation\np = Permutation([2, 0, 1])\n# to Compute its inverse we do\np_inv = ~p\nprint(\"Permutation:\", p)\nprint(\"Inverse Permutation:\", p_inv)\n\nPermutation: (0 2 1)\nInverse Permutation: (0 1 2)\n\n\nHere,on applying p followed by its inverse p_inv returns elements to their original positions.\n\n\n 3. Order of Permutation\n\n\n\nThe smallest positive integer k such that applying the permutation k times results in the identity permutation.\n\n\nfrom sympy.combinatorics import Permutation\n\n#Here we Define a permutation\np = Permutation([1, 2, 0])\n#To Compute its order we do\norder = p.order()\nprint(\"Permutation:\", p)\nprint(\"Order of the Permutation:\", order)\n\nPermutation: (0 1 2)\nOrder of the Permutation: 3\n\n\nApplying this permutation 3 times (i.e the order) returns the set to its original configuration.\n\n\n 4. Parity of Permutation\n\n\n\nIndicates whether a permutation is even or odd, based on the number of transpositions (pairwise swaps) required to achieve it.\n\n\nfrom sympy.combinatorics import Permutation\n\n#here we Define a permutation\np = Permutation([1, 0, 2])\n#to check its parity we do\nis_even = p.is_even\nprint(\"Permutation:\", p)\nprint(\"Is the permutation even?\", is_even)\n\nPermutation: (2)(0 1)\nIs the permutation even? False\n\n\nAs we can see this permutation is odd, as it can be achieved with a single transposition: swapping elements 0 and 1.\n\n\n 5. Cyclic Decomposition\n\n\n\nExpressing a permutation as a product of disjoint cycles, where each cycle represents a subset of elements permuted among themselves.\n\n\nfrom sympy.combinatorics import Permutation\n\n#Here we Define a permutation\np = Permutation([2, 0, 1, 4, 5, 3])\n#To Get its cyclic form we do\ncycles = p.cyclic_form\nprint(\"Permutation:\", p)\nprint(\"Cyclic Decomposition:\", cycles)\n\nPermutation: (0 2 1)(3 4 5)\nCyclic Decomposition: [[0, 2, 1], [3, 4, 5]]\n\n\nThis permutation consists of two disjoint cycles: one cycling elements 0, 2, and 1; the other cycling elements 3, 4, and 5.\n\n\nTopic 5:- Permutation Groups\n\n\n\nIn SymPy, a permutation group is a collection of permutations (rearrangements) that follow group properties. It is represented using the PermutationGroup class in sympy.combinatorics.\n\n\nHow to create Permutation Group in SymPy?\n\n\nSo first step is to create permuations: A permutation is represented as a list where indices represent elements, and values represent their new positions after permutation\n\n\nfrom sympy.combinatorics import Permutation, PermutationGroup\n\n# Defining permutations\np1 = Permutation([1, 2, 0]) # -&gt; (0 1 2)\np2 = Permutation([2, 0, 1]) # -&gt; (0 2 1)\n\n# Creating a group\nG = PermutationGroup([p1, p2])\n\nprint(\"Permutation Group:\", G)\n\nPermutation Group: PermutationGroup([\n    (0 1 2),\n    (0 2 1)])\n\n\nA permutation group consists of multiple permutations as shown above.\n\n\n\nProperties of Permutation Group\n\n\n\n 1. Identity of a group\n\n\n\nEvery group must have an identity element that does nothing.\n\n\nprint(\"Identity Element of the Group:\", G.identity)\n\nIdentity Element of the Group: (2)\n\n\n\nThis confirms that [0, 1, 2] is the identity permutation.\n\n\n\n 2. Order of the group\n\n\n\nThe order of a group is the total number of distinct elements it contains.\n\n\nprint(\"Order of the Group:\", G.order())\n\nOrder of the Group: 3\n\n\n\nThe group has 3 unique permutations, thus the order is 3.\n\n\n\n 3. Finding group elements\n\n\n\nThe .generate() method lists all permutations in the group.\n\n\nprint(\"Elements of the Group:\", list(G.generate()))\n\nElements of the Group: [Permutation(2), Permutation(0, 1, 2), Permutation(0, 2, 1)]\n\n\n\nIt suggests that the group consists of three distinct permutations.\n\n\n\n 4. Permutation Check\n\n\n\nChecking If a Permutation is in the Group\n\n\np_test = Permutation([2, 1, 0])  \nprint(\"Is p_test in the Group?\", p_test in G)\n\nIs p_test in the Group? False"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quarto Template",
    "section": "",
    "text": "Quarto template Text! # This is the home page"
  }
]